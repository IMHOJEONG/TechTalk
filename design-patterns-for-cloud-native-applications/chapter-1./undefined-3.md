---
description: '-'
---

# 클라우드 네이티브 애플리케이션 디자인 패턴

* 통신, 연결성과 조합, 데이터 관리, 이벤트 주도 아키텍처, 스트림 프로세싱, API 관리 및 사용&#x20;
  * 6가지 측면과 관련된 패턴들을 살펴보자&#x20;

#### 통신 패턴&#x20;

* 서비스들이 서로, 또는 외부 요소와 어떻게 통신하는지 그 방법
* 만들고자 하는 비즈니스 기능별로 각 서비스는 데이터베이스나 메시지 브로커와 같은 외부 서비스나 시스템을 사용해야 할 수도 있음&#x20;
* 클라우드 네이티브 애플리케이션 내부의 서비스 간 통신&#x20;
  * 동기 또는 비동기 통신 패턴으로 구현&#x20;
  * 동기 통신 : 요청-응답(request-response), RPC
  * 비동기 통신 : 메시지 큐, 발행자-구독자(publisher-subscriber)
* 애플리케이션 개발에선 두 가지 방식을 모두 사용해서 서비스 상호작용을 구현하는 경우가 많음&#x20;
  * 서비스 인터페이스 정의 - 해당 서비스를 어떤 식으로 사용하는지를 알려주기 때문&#x20;
  * 어떤 통신 패턴을 사용할지 결정하는 데에도 중요한 역할&#x20;
* 서비스 간 상호작용 & 외부 애플리케이션과도 통신

#### 연결성 및 조합 패턴&#x20;

* 마이크로서비스 수가 늘어날수록 더 많은 서비스 간 통신이 생길 수 있음&#x20;
* 연결성 - 서비스 간 통신이라는 관점 => 서비스 간 믿을 수 있고 안전하며, 찾기 쉽고 관리가 편하며 관측 가능성이 뛰어난 통신 매체를 제공하는 것을 의미&#x20;
  * ex) 어떤 한 서비스가 다른 서비스를 사용할 때, 보안성이 뛰어나거나 혹은 접속이 불안정할 때 재접속을 지원하는 기능&#x20;
* 조합 - 클라우드 네이티브 애플리케이션에선, 여러 서비스나 시스템을 연결 또는 통합하여 새로운 서비스를 만들기도 함&#x20;
* 서비스나 시스템들 => SOA에서도 많이 사용했었음&#x20;
  * SOA에서 모든 서비스, 데이터, 시스템은  ESB로 통합&#x20;
  * SOA에서 새로운 조합을 만들 때 ESB는 당연한 선택이 될 수 밖에 없었음&#x20;
  * EIP(Enterprise Integration Pattern)이라 불리는 이 구조에선 과도하게 많은 조합 패턴이 사용되었음&#x20;
* 클라우드 네이티브 분야 - 이러한 중앙화된 조합 계층이 없음&#x20;
  * 대신 서비스 조합 => 전부 서비스를 개발하는 과정에서 이루어짐&#x20;

#### 데이터 관리 패턴&#x20;

* 클라우드 네이티브 애플리케이션 => 데이터 관리&#x20;
* 애플리케이션의 상태나 서비스에 필요한 비즈니스 데이터를 저장하기 위한 영구 스토어로 DB를 주로 사용&#x20;
* 기본적으로 분산 구조 = 데이터 관리 역시 중앙화된 방법이 아닌, 분산 방식으로 이루어짐&#x20;
* 전통적인 모놀리식 애플리케이션&#x20;
  * 중앙화된 공유 데이터 스토어를 여러 애플리케이션이 함께 사용&#x20;
*   클라우드 네이티브 애플리케이션&#x20;

    * 각 마이크로서비스가 자신만의 데이터 스토어를 가짐&#x20;
    * 다른 서비스나 외부 시스템 등은 오직 서비스 인터페이스를 통해서만 해당 데이터에 접근 가능&#x20;
    * 데이터 관리의 분산 => 마이크로서비스 간 데이터를 공유, 접근, 동기화하는 것이 어려워진다는 문제&#x20;
    * 데이터 관리 패턴이 무엇보다 중요&#x20;



#### 이벤트 주도 아키텍처 패턴&#x20;

* 이벤트 주도 클라우드 네이티브 애플리케이션의 근간 = 비동기 통신&#x20;
*   EDA(이벤트 주도 아키텍처) - 애플리케이션 개발 분야에서 수십 년간 사랑받아 온 방식&#x20;


* 마이크로서비스를 독립적이고 자율적으로 동작할 수 있도록 만드는 중요한 역할&#x20;
  * 질의나  RPC를 통해 직접적으로 통신하는 동기 통신 기법에 비해
  * EDA : 마이크로서비스 간 상호작용을 좀 더 느슨하고 유연하게 만들어 줌&#x20;



* 큐 기반, 발행자-구독자와 같은 이벤트 전달 패턴&#x20;
  * 딜리버리 시맨틱, 신뢰성, 이벤트 스키마&#x20;

#### 스트림 프로세싱 패턴&#x20;

* EDA에선 한 번에 하나의 이벤트만 처리&#x20;
  * 마이크로서비스에 구현한 비즈니스 로직이 한 번에 하나의 이벤트만 처리하도록 구현했다고 할 수 있음&#x20;
  * 이벤트와 그 뒤의 이벤트는 아무런 상관관계가 없음&#x20;
* Stream : 서로 밀접한 관계를 가지며 시간에 따라 지속적으로 유입되는 일련의 이벤트나 데이터들
  * 일련의 이벤트들 : 애플리케이션이 현재 상태를 계속 저장하고 관리하면서 처리해야 함&#x20;
  * 이러한 작업을 처리해야 하는 마이크로서비스는 그 상태를 저장하고 데이터를 효율적으로 처리 & 확장성, 동시성을 만족해야 함
* 스트림 프로세싱 : 스트림을 생산하거나 처리하는 애플리케이션 로직&#x20;
  * 연속적인 데이터 스트림을 상태를 관리하면서 처리해야 하는 요구가 늘어나면서&#x20;
    * 클라우드 네이티브 애플리케이션에서 이런 스트림 기반 아키텍처를 사용하는 경우 점점 늘어나고 있음&#x20;

#### API 관리 및 사용 패턴&#x20;

* 규모 이상의 클라우드 네이티브 아키텍처 => 애플리케이션의 특정 비즈니스 기능들을 내부 or 외부 시스템에 제공하는 경우가 많음&#x20;
* 관리형 서비스 or 관리형 API를 통해 외부 시스템이 이런 기능들을 사용하는 것을 제어 or API등을 통해 사용하고자 하는 기능을 쉽게 찾을 수 있거 만들고 피드백을 제공받을 수도 있음
* 별도의 API 게이트웨이를 두어 마치 애플리케이션에 접근할 수 있는 대문처럼 만드는 경우가 많음&#x20;
  * API 게이트웨이 : 관리 기능과 개발자 포털을 함께 제공&#x20;
