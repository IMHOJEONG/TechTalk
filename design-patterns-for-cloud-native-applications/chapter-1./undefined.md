---
description: '-'
---

# 클라우드 네이티브의 개념

* CNCF의 정의&#x20;
  * &#x20;클라우드 네이티브 기술 = 퍼블릭, 프라이빗, 하이브리드 클라우드와 같은 실행 환경에서 그 크기를 자유롭게 조절할 수 있는 애플리케이션을 만들고 실행할 수 있는 능력을 제공해 줌&#x20;
  * Container, Service Mesh, 마이크로서비스, 불변 인프라스트럭처(immutable infrastructure), 선언적 API(Declarative API)들을 활용하여 구현할 수 있음&#x20;
    * 관리, 관찰이 쉽고 탄력성 있는 느슨하게 결합된 시스템을 만들 수 있음&#x20;
* 클라우드 네이티브&#x20;
  * 퍼블릭이나 프라이빗, 하이브리드, 멀티 클라우드와 같은 환경에서 실행할 수 있는 독립적인 비즈니스 기능 중심의 마이크로서비스들을 느슨하게 결합하여
  * 크기 조절이 가능하고 탄력적이며 관리와 관찰이 용이한 자동화된 소프트웨어 애플리케이션을 만드는 것을 의미&#x20;

#### 마이크로서비스로 구성하는 설계&#x20;

* 클라우드 네이티브 애플리케이션은 독립적으로 만들어진 서비스들을 느슨하게 결합하는 것으로 설계됨&#x20;
* 각 서비스는 각각에 주어진 비즈니스 요구를 잘 충족시켜야 함&#x20;
  * 이런 조건을 만족하는 서비스들을 `Microservice` 라고 함&#x20;
* 마이크로서비스?
  * 클라우드 네이티브 애플리케이션에서 없어서는 안 될 필수적인 기본 요소&#x20;
  * 마이크로서비스 아키텍처 = 소프트웨어 애플리케이션을 만드는 방법&#x20;
    * 이 아키텍처가 출현하기 전까지, 복잡한 비즈니스 요구사항을 전부 충족하기 위해서 모놀리식 애플리케이션을 만들어왔음&#x20;
* 모놀리식 애플리케이션 = 근본적으로 복잡하고 크기 조절이 어렵고 유지보수 비용이 많이 소요되며 개발의 민첩성이 떨어짐&#x20;
  * 모놀리식 애플리케이션 => 다른 모놀리식 애플리케이션과 전용 프로토콜을 사용해 주로 통신하며 단일 데이터베이스를 함께 쓰는 경우가 많음&#x20;
* **마이크로서비스 아키텍처 = 독립적으로 개발하고 배포하고 크기 조절이 가능한 비즈니스 기능 지향 서비스들을 느슨하게 결합하여 소프트웨어 애플리케이션을 만드는 방법**

&#x20;

* 서비스 지향 아키텍처(Service Oriented Architecture)(SOA)&#x20;
  * 기존 모놀리식 애플리케이션 아키텍처의 한계를 해결할 수 있는 더 나은 아키텍처로 부각
  * 특정 비즈니스 기능을 지원하는 서비스들을 조합해 소프트웨어 애플리케이션을 만드는 모듈성 개념을 선보임&#x20;
  * 웹 서비스 등과 같이 SOA로 구현된 서비스들은 복잡한 표준과 메시지 포맷을 사용하였으며 중앙 집중화된 모놀리식 컴포넌트를 아키텍처에 포함하기도 했음&#x20;



* SOA에 기반하여 설계한 소프트웨어 애플리케이션들은 웹 서비스와 같은 여러 서비스를 만들고&#x20;
  * 개방형 표준과 엔터프라이즈 서비스 버스(Enterprise Service Bus)(ESB)로 알려진 중앙 집중형 모놀리식 통합 계층을 사용해 이들을 한데 묶음&#x20;
  * 그리고 API 관리 계층을 두어서 이 SW 애플리케이션에서 제공하는 비즈니스 기능들을 API로 제공할 수 있음&#x20;



* 많은 엔터프라이즈 솔루션이 이러한 구조를 채택했으며, 아직도 많은 수의 엔터프라이즈 소프트웨어가 SOA에 기반해 설계되고 만들어지고 있음&#x20;
  * SOA 역시 그 근본적인 복잡성과 한계 때문에 제공하는 소프트웨어 애플리케이션 개발 시 민첩성을 떨어트림&#x20;
* SOA 구조로 만든 SW는 독립적으로 크기 조절하기 힘들고, 애플리케이션 내부의 의존성 때문에 제공하는 서비스들을 독립적으로 개발하고 배포하기 어려움&#x20;
  * 게다가, 중앙 집중화 애플리케이션 형태여서 신뢰성이 떨어질 뿐만 아니라 애플리케이션 개발 시 서로 다른 다양한 기술을 사용하기가 어려움&#x20;



* 반면, 마이크로서비스 아키텍처는 좀 더 잘 만들어진 비즈니스 중심적 서비스를 도입하고 ESB와 같은 중앙화 컴포넌트들을 제거&#x20;
  * 마이크로서비스 아키텍처에서 SW 애플리케이션은 비즈니스 핵심 기능을 구현한 독립적인 서비스들로 구성됨&#x20;
  * 각각의 서비스들은 개별 팀에서 독립적으로 개발하고 배포하고 관리할 수 있음&#x20;



* 서비스를 통합하기 위해 마이크로서비스 아키텍처에서는 ESB 계층을 사용하는 대신 각각의 마이크로서비스가 다른 마이크로서비스와 내부에서 알아서 통신하도록 만듬&#x20;
  * 이러한 통신 기능 => 각 마이크로서비스가 제공하는 비즈니스 기능을 구현하는 데 꼭 필요!
* 마이크로서비스 아키텍처 = 잘 정의된 엔드포인트(smart endpoint)들을 단순한 연결 수단(dumb pipe)으로 연결하였다고도 표현함&#x20;
*   마이크로서비스

    * 외부의 시스템과 연결하거나 다른 시스템에서 사용할 수 있는 파사드(facade)라고 불리는 간단한 인터페이스를 제공하기도 함&#x20;
    * 데이터베이스를 함께 사용하지 않으며 외부에서는 오직 서비스 인터페이스를 통해서만 데이터에 접근할 수 있음&#x20;
    * 각각의 마이크로서비스는 탄력성과 보안성 등 수많은 기본 요건을 충족시킬 수 있는 서비스 간 통신 기능과 비즈니스 로직을 구현해야만 함&#x20;


*   클라우드 네이티브 애플리케이션이 마이크로서비스의 조합으로 만들어지는 것&#x20;

    * 마이크로서비스 아키텍처에 적용되는 대부분의 개념은 클라우드 네이티브에도 거의 동일하게 적용됨&#x20;



### 컨테이너와 컨테이너 오케스트레이션&#x20;

* 마이크로서비스가 클라우드 네이티브 애플리케이션 설계 및 개발에서 중요한 역할을 맡고 있다면&#x20;
  * 패키징과 실행에서 컨테이너가 그만큼 중요한 역할을 담당
* 클라우드 네이티브 애플리케이션을 개발하는 경우 마이크로서비스는 컨테이너 이미지로 패키징하고 컨테이너 실행 환경에서 동작&#x20;

#### 컨테이너?

* 컨테이너 전용 파일 시스템을 통해 컨테이너 이미지를 제공받음&#x20;
* 컨테이너 이미지 = 애플리케이션 코드, 의존성 라이브러리, 실행 환경 등 애플리케이션 실행에 필요한 모든 것을 가지고 있는 이진 데이터&#x20;
* 컨테이너 이미지는 수정이 불가능하며 컨테이너 레지스트리(Container Registry)라는 스토어에 주로 보관됨&#x20;
* 컨테이너는 컨테이너 이미지를 통해 컨테이너 인스턴스(Container Instance)라고 불리는 프로세스를 만들어서 실행
* 컨테이너 인스턴스는 컨테이너 런타임 엔진에서 실행됨&#x20;



* VM은 하이퍼바이저(hypervisor)를 통해 호스트의 CPU나 메모리 같은 컴퓨팅 자원을 사용해 게스트 운영체제를 실행&#x20;
* 컨테이너는 컨테이너 런타임 엔진에서 실행하며 호스트의 커널과 프로세서, 메모리를 다른 컨테이너와 함께 사용&#x20;
  * VM에서 실행하는 것과 비교해 봤을 때 컨테이너에서 마이크로서비스를 실행하는 것이&#x20;
    * 더 가벼우면서도 분리된 프로세스 환경을 제공해 준다고 할 수 있음&#x20;



* 마이크로서비스나 애플리케이션을 컨테이너 환경에서 실행할 수 있도록 만드는 것 = 컨테이너화(Containerization)
  * 컨테이너화를 통해 마이크로서비스를 좀 더 옮기기 쉽고&#x20;
    * 여러 환경에서도 동일하게 실행되도록 만들 수 있음&#x20;



* 컨테이너는 마이크로서비스를 캡슐화하여 독립적이고 자율적인 서비스로 만드는 핵심 기술
  * 컨테이너화된 마이크로서비스는 다른 마이크로서비스를 전혀 방해하지 않고 다른 서비스로 대체되거나 업그레이드될 수 있음
* 컨테이너 기술을 사용하면 VM에 비해 컴퓨팅 자원을 더 효율적으로 사용할 수 있음&#x20;
  * 실행에 필요한 런타임 환경을 더 작게 만들고 불필요한 실행 환경 설정 등을 제거할 수 있음&#x20;
  * VM에 비해 훨씬 가볍다는 이점도 있음&#x20;



* 마이크로서비스를 컨테이너화해서 컨테이너 환경에서 실행하는 것&#x20;
  * 클라우드 네이티브 애플리케이션의 라이프사이클 일부분에 불과&#x20;
  * 실행되는 컨테이너의 관리, 컨테이너들의 라이프사이클들은 어떻게 관리해야 할까?
    * 컨테이너 오케스트레이션이 필요한 이유!

#### 왜 컨테이너 오케스트레이션이 필요한가?

* 컨테이너 오케스트레이션 : 컨테이너의 라이프사이클을 관리하는 일종의 체계
* Automatic Provisioning - 자동화된 프로비저닝&#x20;
  * 자동으로 컨테이너 인스턴스를 생성하고 배포&#x20;
* High Availability - 고가용성&#x20;
  * 컨테이너가 실행 도중 중단될 경우 자동으로 컨테이너 인스턴스를 다시 생성&#x20;
* Scaling - 크기 조절&#x20;
  * 요구 조건에 따라 컨테이너 인스턴스 수를 늘리거나 줄여서 애플리케이션 크기를 조절
* Resource Management - 자원 관리&#x20;
  * 컨테이너에 적절한 자원을 할당해줌&#x20;
* Service Interface & Load Balancing - 서비스 인터페이스 및 부하 분산&#x20;
  * 컨테이너를 외부 시스템에서도 접근할 수 있도록 만들어주며 시스템에 주어지는 부하를 컨테이너에 고루 분산&#x20;
* Networking infrastructure Abstration - 기저 네트워크 추상화&#x20;
  * 오버레이 네트워크를 제공하여 컨테이너 간 통신을 가능하게 함&#x20;
* Service Discovery - 서비스 검색
  * 서비스 이름으로 서비스를 찾을 수 있는 내장 기능&#x20;
* Control Plane - 컨트롤 플레인&#x20;
  * 컨테이너 시스템을 관리하고 모니터링할 수 있는 시스템을 제공&#x20;
* Affinity - 어피니티
  * 필요에 따라 컨테이너들을 가까이, 또는 서로 멀리 배치함으로써&#x20;
  * 가용성 또는 목표 성능을 달성할 수 있도록 함&#x20;
* Health Monitoring - 상태 모니터링&#x20;
  * 오류나 실행 중단을 자동으로 탐지하고 스스로 복구할 수 있도록(self-healing) 만듬&#x20;
* Rolling Upgrade - 롤링 업그레이드&#x20;
  * 시스템을 중단하지 않고도 컨테이너들을 점진적으로 업그레이드할 수 있음&#x20;
* Componentization and Isolation - 요소화 및 격리&#x20;
  * Namespace(네임스페이스)와 같은 논리적 구분 방법을 제공하여&#x20;
  * 여러 애플리케이션 도메인을 요소화하고 서로 격리&#x20;



* 클라우드 네이티브 관점 => 현재로서는 Kubernetes가 표준 컨테이너 오케스트레이션 시스템이라 할 수 있음&#x20;



