---
description: '-'
---

# 클라우드 네이티브의 개념 (2)

#### 쿠버네티스

* 자동화된 배포, 크기 조절, 장애 복구, 네트워크 등 컨테이너 관리에 필요한 수많은 기능들을 제공하여&#x20;
  * 컨테이너들을 쉽게 관리할 수 있는 추상화된 계층을 제공&#x20;
  * 쿠버네티스가 점점 더 많은 플랫폼이나 클라우드 벤더에 의해 채택되면서, 전세계적으로 사랑받는 컨테이너 관리 플랫폼&#x20;
* 쿠버네티스는 애플리케이션 워크로드(workload)를 이식이 쉽고 크기 조절이 자유로우며 확장이 쉽도록 만들어 줌&#x20;
  * 어떻게 보면 애플리케이션을 설계하는 표준 플랫폼이기 때문에, 쿠버네티스의 기저에 있는 인프라스트럭쳐를 전혀 신경 쓸 필요가 없음&#x20;



* 쿠버네티스 클러스터는 실제 물리적 서버 또는 가상 머신들로 노드를 구성
  * 이 노드들 중 적어도 하나는 컨트롤 플레인 노드가 되어야 하며 그 외 여러 워커 노드로 구성함&#x20;
* Control Plane Node - 클러스터에 애플리케이션 인스턴스를 스케쥴링하고 관리하는 역할을 맡음&#x20;
  * 이렇게 쿠버네티스를 관리하는 노드를 쿠버네티스 컨트롤 플레인이라고 지칭&#x20;



*   쿠버네티스 API 서버는 컨트롤 플레인 노드들과 워커 노드들 사이의 모든 통신을 도맡음&#x20;

    * 특정 애플리케이션 워크로드가 워커 노드에서 실행되어야 하는 경우,&#x20;
      * 쿠버네티스 스케줄러(kube-scheduler)가 각 워커 노드의 가용 자원과 정책을 고려해서 워크로드에 적당한 노드를 지정&#x20;


* 각 쿠버네티스 노드들에서는 노드 상태를 관리하는 kubelet 이라는 에이전트가 실행됨&#x20;
  * kubelet은 쿠버네티스 API 서버와 직접 통신해서 해야 할 일을 전달받고 현재 노드의 상태를 알려줌&#x20;
  * 파드(Pod) : 주어진 노드에서 실행되는 애플리케이션 실행 환경을 의미하는 가장 기본적인 배포단위&#x20;
  * 하나의 Pod에서 한 개 이상의 컨테이너를 실행할 수 있음&#x20;
  * 각 파드는 쿠버네티스 클러스터 내에서 고유한 IP 주소를 할당받음&#x20;



* 쿠버네티스는 이 외에도 서비스나 디플로이먼트, 레플리카셋과 같은 추상화 요소들로 애플리케이션 배포와 관리를 더 쉽게 만들어 줌&#x20;
  * 서비스 - 여러 파드를 하나의 네트워크 서비스로 논리적으로 묶어줌&#x20;
    * 이 서비스를 통해 여러 파드에 부하를 고루 분산할 수 있음&#x20;
  * 레플리카셋 - 애플리케이션에서 지정한 파드 수를 정의하고 관리
  * 디플로이먼트 - 애플리케이션에 대한 변경 사항을 처리하고 이를 레플리카셋 또는 파드에 반영&#x20;



#### 서버리스&#x20;

* 클라우드 네이티브 애플리케이션의 특정 마이크로서비스는 서버리스 형태로 구현할 수 있음&#x20;
* 서버리스 형태로 구현한 마이크로서비스는 클라우드 인프라스트럭쳐상의 서버리스 플랫폼에서 동작하며
  * 서버리스 플랫폼은 필요한 관리 기능이나 네트워크, 탄력성, 확장성, 보안 등의 요소를 제공&#x20;
* AWS Lambda, Azure Function, Google Cloud Function이 이러한 서버리스 플랫폼에 해당&#x20;
* 부하에 따라 자동으로 인스턴스 크기를 조절하며, 여러 프로그래밍 언어를 지원하고
  * 탄력적인 네트워크, 보안성, 관측 가능성을 구현하기 위한 다양한 내장 기능을 제공&#x20;
* 마이크로서비스 중에서 특정 시간에 부하가 몰리는 경우나 배치 작업을 처리하는 경우
  * 이벤트 주도 서비스를 처리하는 경우가 서버리스에 적합하다고 볼 수 있음&#x20;



*   서버리스 플랫폼을 사용하면 실제 애플리케이션 인스턴스는 컨테이너로 실행되지만&#x20;

    * 개발자들은 컨테이너로 실행된다는 사실을 알지 못함&#x20;


* 개발자들이 해야 할 일은 비즈니스 로직을 구현하고 서버리스 플랫폼에 이를 전달하는 것이 전부&#x20;
* 서버리스 플랫폼은 이 코드를 관리 및 배포하고 실행하는 자세한 내용을 사용자나 개발자에게 전혀 알려주지 않음&#x20;

#### 가상 머신&#x20;

* 컨테이너 없이 마이크로서비스를 실행할 수도 있음&#x20;
* 클라우드 네이티브 애플리케이션을 반드시 Container로 만들어야 하는 것은 아니지만&#x20;
* 컨테이너를 사용하지 않는 경우, VM에서 애플리케이션을 실행해야 하기 때문에
  * 실행과 관리가 더 복잡해짐
* 이러한 이유로! 클라우드 네이티브 아키텍처에서는 대부분 컨테이너와 컨테이너 오케스트레이션, 또는 서버리스와 같이 더 추상화된 기능을 사용함&#x20;



### 개발 라이프사이클을 자동화

* 클라우드 네이티브 애플리케이션을 배포할 때 무엇보다 중요한 것은?
  * 민첩성, 속도, 안전성&#x20;
* `자동화` : 개발 라이프사이클에서 수동으로 직접 하는 작업들을 자동화하는 것&#x20;
* 통합 테스트, 빌드, 릴리스, 설정 관리, 인프라스트럭쳐 관리, 지속적 통합, 지속적 전달/배포

#### 개발 라이프사이클?

* 개발자가 코드를 작성하고 실행하고 디버깅한 다음 Git과 같은 중앙 코드 관리 스토어에 변경점을 Push하는 것으로 시작&#x20;
* 코드를 푸시하면, 지속적 통합 단계를 자동으로 시작&#x20;
  * 이 단계에서 코드를 빌드하고 테스트를 실행한 다음 문제가 없으면 애플리케이션을 바이너리 형태로 패키징함&#x20;
* 지속적 통합 도구는 변경된 코드에 대해 애플리케이션을 빌드하고 자동으로 단위 테스트를 실행한 다음 발견한 오류들을 표시
* 빌드 결과물을 각기 다른 환경에 배포하는 상황에서 지속적 배포 단계가 등장&#x20;
  * 이 단계에서는 설정 관리 도구를 통해 각 환경에 알맞게 빌드한 결과물을 골라서 해당 설정과 잘 맞는 환경에 배포&#x20;
  * 변경된 빌드 결과물을 운영 시스템에 배포하기 전 여러 테스트를 병렬로 실행할 수도 있음&#x20;
  * 결과물을 운영 시스템에 적용하는 작업은 자동화할 수도 있고, 승인 과정을 거쳐 수동으로 진행할 수 있음&#x20;



* 지속적 전달과 지속적 배포는 여기에서 차이가 생기는데,&#x20;
  * 승인 과정을 통해 수동으로 운영 시스템에 적용하는 것을 지속적 전달이라고 함&#x20;
  * 지속적 배포 : 승인이나 수동 작업 없이 변경된 코드가 운영 시스템에 적용되는 전 과정이 전부 자동으로 이루어짐&#x20;



*   코드형 인프라스트럭쳐(IaC, Infrastructure as Code)

    * 개발이나 검증, 운영과 같이 배포 대상이 되는 각기 다른 실행 환경을 구성할 때
    * IaC에선 네트워크나 가상 머신 등의 인프라스트럭처를 마치 애플리케이션의 소스 코드와 같이 정의하는 모델을 사용&#x20;
      * 이러한 모델 => 수동으로 인프라스트럭처를 구성하고 관리할 필요 없이 요구 조건을 명세하는 것만으로 필요한 환경을 계속 만들 수 있음&#x20;
    * 개발 과정에서 요구하는 환경과 실행 환경의 일관성을 쉽고 빠르고 효율적으로 유지할 수 있으며 관리 부담도 줄어듬&#x20;
      * IaC 역시 지속적인 배포 환경에서 아주 중요한 부분


* 배포를 어디에 어떤 식으로 할 것인지 결정하고 나면, 쿠버네티스와 같은 플랫폼에서&#x20;
  * 조정 루프(reconciliation loop)를 통해 배포 상태를 계속 관리할 수 있음&#x20;
  * 사용자, 관리자 개입 없이 배포 상태를 알아서 관리하고 유지하는 것&#x20;
  * ex) 특정 시점에 애플리케이션 인스턴스가 반드시 세 개가 유지되어야 한다고 명세하면&#x20;
    * 쿠버네티스는 조정 루프를 거쳐 애플리케이션 인스턴스가 항상 3개인지 확인하고 관리

### 동적 관리&#x20;

* 클라우드 네이티브 애플리케이션을 운영 환경에 배포하고 나면, 애플리케이션이 어떻게 동작하는지 모니터링하고 관리해야 함&#x20;

#### 오토스케일링(autoscaling)

* 애플리케이션 인스턴스 크기나 수를 트래픽이나 부하 등에 따라 늘리거나 줄임&#x20;

#### 고가용성(high availabilty)

* 오류나 실행 중단 등의 이상을 감지할 경우,&#x20;
  * 현재 애플리케이션 인스턴스가 실행되고 있던 데이터 센터에 새로운 인스턴스를 만들거나, 다른 데이터 센터로 트래픽을 보냄&#x20;

#### 자원 최적화(Resource Optimization)

* 고정된 비용을 미리 지불하는 방식이 아닌, 실시간 요구에 따라 동적으로 크기를 조절하고 비용 등을 청구하는 방법으로 자원을 최적으로 사용함&#x20;

#### 관측 가능성(Observability)

* 로그, 메트릭 등의 클라우드 네이티브 애플리케이션 정보를 중앙에서 수집하고 제공&#x20;

#### 서비스 품질(Quality of Service, QoS)

* end-to-end security(단말 간 보안), throttling(스로틀링), compliancy(규정 및 정책 준수), versioning(버전 관리)를 지원&#x20;

#### 중앙 컨트롤 플레인(Central control plane)

* 클라우드 네이티브 애플리케이션의 모든 부분을 관리할 수 이쓴 중앙화된 제어 방법을 제공&#x20;

#### 자원 프로비저닝(Resource Provisioning)

* 애플리케이션 별 CPU, 메모리, 스토리지, 네트워크 등의 자원을 할당하고 관리&#x20;

#### 멀티클라우드 지원(Multicloud support)

* 프라이빗, 퍼블릭, 하이브리드 등 여러 클라우드 환경에서 애플리케이션을 실행하고 관리할 수 있는 기능을 제공&#x20;
* 특히 애플리케이션이 여러 클라우드 서비스 제공자들의 서비스 등을 필요로 하는 경우 이 기능이 중요&#x20;
* AWS, Azure, GCP 등은 이러한 동적 기능 대부분 제공&#x20;
* 컨테이너 및 오케스트레이션 환경은 클라우드 네이티브 애플리케이션이 특정 클라우드 환경에 종속되지 않고&#x20;
  * 여러 환경에서 실행할 수 있도록 하는 중요한 역할을 맡음&#x20;
  *





