---
description: '-'
---

# 클라우드 네이티브 애플리케이션 개발 방법론

* 클라우드 네이티브 애플리케이션 개발 과정에선 익숙한 개발 방법이 아닌,
  * 전혀 새로운 개발 방법론을 따라야 함&#x20;
  * 원래는 Twelve-Factor app 개발 방법론이 있었지만 현실적인 개발과 몇 가지 부분에서 잘 맞지 않았음&#x20;
* 애플리케이션 설계 => 애플리케이션 개발 => 연결성 및 API 구현 => 개발, 릴리스, 배포 자동화 => 동적 환경에서 실행 => 동적 환경 관리를 위한 컨트롤 플레인 구현 => 관측 가능성 구현&#x20;
  * 애플리케이션 개발&#x20;
    * 독립된 코드베이스&#x20;
    * 명시적 의존성&#x20;
    * 별도의 설정 관리&#x20;
    * 독립 테스트&#x20;
    * 컨테이너화
  * 연결성 및 API 구현&#x20;
    * 서비스 주도 상호작용&#x20;
    * 서비스 간 통신 및 조합&#x20;
    * 기능을 관리형 API로 외부에 제공하기&#x20;
* 관측 가능성 구현을 통해 애플리케이션에 대한 통찰력을 얻고, 이를 다음 주기 애플리케이션 설계에 반영할 수 있음&#x20;

#### 애플리케이션 설계&#x20;

* 마이크로서비스를 차용한 클라우드 네이티브 애플리케이션을 만들 때 애플리케이션 개발에 곧바로 뛰어들 수 없음&#x20;
  * 그 전에 구현해야 할 비즈니스 핵심 기능을 파악하고 애플리케이션을 설계해야만 함&#x20;
* 설계 과정에서 애플리케이션이 제공해야 할 비즈니스 핵심 기능과 아울러&#x20;
  * 애플리케이션이 사용할 서비스나 시스템 등 외부 의존성 관계 역시 정확하게 파악해야 함&#x20;
* 따라서, 애플리케이션 설계 단계에서 비즈니스 기능들을 사용 사례별로 자세히 관찰하고 만들고자 하는 마이크로서비스를 정확히 파악해야 함&#x20;
* 도메인 주도 설계(DDD) 방법을 쓸 수 있음&#x20;



#### 도메인 주도 설계

* 각각의 주도 설계에 대한 자세한 내용은 에릭 에반스의 도메인 주도 설계를 참고하기를 바람&#x20;
* 비즈니스가 어떤 분야인지를 파악하고, 해당 도메인 내에서 특정 도메인 모델을 적용할 수 있는 경계들을 나눔&#x20;
* bounded context라 부름&#x20;
* ex) 회사의 조직은 영업, 인사, 지원 조직 등으로 나눌 수 있음&#x20;
  * 각각의 bouned Context는 aggregate로 나눌 수 있음&#x20;
  * 이는 단일 구성 단위로 다룰 수 있는 메인 개체 클러스터



* 각각의 bounded context는 마이크로서비스와 1:1로 대응할 수도, 아닐 수도 있음&#x20;
* 클라우드 네이티브 애플리케이션을 설계할 떄는&#x20;
  * 바운디드 컨텍스트 별로 서비스를 만들고,&#x20;
  * 설계를 진행하면서 점차 aggregate 단위로 서비스를 더 잘게 쪼개는 경향이 있음&#x20;



*   애플리케이션에 대한 도메인 주도 설계가 끝나면 마이크로서비스를 정의함과 동시에

    * 서비스들에 대한 정의 및 인터페이스, 그리고 통신 방식도 결정하게 됨&#x20;



### 애플리케이션 개발&#x20;

* 개발 단계에선 비즈니스 기능이 동작하는 방식에 기반해 애플리케이션과 서비스 인터페이스들을 구현&#x20;

#### 독립 코드베이스&#x20;

* 클라우드 네이티브 애플리케이션을 구성하는 각 마이크로서비스
  * 깃과 같은 버전 관리 시스템 기반 코드베이스를 가져야 함&#x20;
* 각 서비스를 하나 이상의 인스턴스 형태로 배포하고 실행
  * 개발, 검증, 운영과 같이 각기 다른 독립적인 환경에 배포하고 실행하지만
  * 모두 같은 코드베이스를 사용&#x20;
  * 물론 각 환경에 따라 동일한 코드베이스의 다른 코드 버전을 사용할 수도 있음&#x20;
* 독립 코드베이스는 각 마이크로서비스의 라이프사이클이 시스템의 다른 부분과 완벽하게 독자적으로 진행될 수 있도록 함&#x20;
* 또한 각 서비스별로 필요한 라이브러리 등의 외부 의존성을 명시적으로 지정할 수도 있음&#x20;

#### 명시적 의존성&#x20;

* 마이크로서비스 코드 수준의 의존성은 반드시 명시적으로 선언해야 하며
  * 다른 서비스들의 의존성과는 별도로 구분해서 관리해야 함&#x20;
* 마이크로서비스 코드의 일부분으로서 의존성들을 매니페스트로 선언하고 관리하고 사용해야 함
  * 또한, 그 외 명시적으로 선언하지 않는 시스템 수준의 라이브러리나 요소 등에는 절대로 의존해서는 안 됨&#x20;

#### 별도의 설정 관리&#x20;

* 단일 코드베이스에 작성한 클라우드 네이티브 애플리케이션은 다양한 환경에 배포할 수 있음&#x20;
* 마이크로서비스 관련 설정들이 마이크로서비스 코드와 완전히 별개로 존재해야만 가능&#x20;
* 환경에 전혀 영향을 받지 않으며, 설정은 배포하는 환경에 따라 각기 다름&#x20;

#### 독립 테스트&#x20;

* 마이크로서비스는 그 기능을 스스로 검사할 수 있는 테스트를 코드에 포함해야 함&#x20;
* 테스트 : 마이크로서비스의 개발 라이프사이클에서 필수 & 일반적으로 빌드 및 배포 단계에서 마이크로서비스를 검증&#x20;
* 단위 테스트 : 각 마이크로서비스 내에서 스스로를 검증하는 것&#x20;



* 클라우드 네이티브 애플리케이션의 많은 마이크로서비스
  * 다른 마이크로서비스와 유기적으로 통신하고 동작하는 경우가 대부분이기 때문&#x20;
  * 애플리케이션의 전반적인 기능을 검사하는 데 단위 테스트만으로는 충분하지 않음&#x20;
  * 통합테스트 : 시스템 전반에 걸친 테스트 역시 필요&#x20;



* 통합 테스트에선 여러 마이크로서비스와 시스템을 한데 묶어서 마치 단위 테스트를 진행하는 것처럼&#x20;
  * 마이크로서비스들이 잘 연동하고 비즈니스 기능이 제대로 동작하는지 검사함&#x20;

#### 컨테이너화&#x20;

* 클라우드 네이티브 애플리케이션을 만드는 데에 컨테이너화가 필수는 아님&#x20;
* 컨테이너화를 통해 대부분의 특성과 요구사항을 더 쉽게 구현할 수 있음&#x20;
* 클라우드 네이티브 애플리케이션의 모든 의존성, 실행 환경, 설정들을 한데 묶어서 단일 패키지로 만드는 것
  * 컨테이너화로 쉽게 끝낼 수 있음&#x20;
* 도커와 같은 기술을 사용한 컨테이너화&#x20;
  * 마이크로서비스 코드를 불변으로 만들어서 원하는 시점에 즉각 시작하거나 중지할 수 있음&#x20;
  * 문제가 있는 인스턴스를 수정하거나 업그레이드하는 대신 그냥 버리는 것으로 해결할 수 있음
* 이를 위해, 마이크로서비스 자체가 빠르게 시작할 수 있고 종료하기 전 정리할 수 있는 기능을 제공해야 함&#x20;



* 여러가지 이유로, 마이크로서비스는 컨테이너 전용 프레임워크와 기술을 사용해야&#x20;
  * 가장 쉽게 컨테이너화할 수 있음&#x20;



*   마이크로서비스를 구현하면 다른 마이크로서비스와 연결하거나 외부 시스템에 API 형태로&#x20;

    * 비즈니스 기능을 제공해야 할 필요도 발생&#x20;



#### 연결성 및 구성, 그리고 API

* 클라우드 네이티브 애플리케이션에선 구성 요소들을 분산 배포하며
  * 각각은 네트워크를 통해 연결됨&#x20;
* 애플리케이션을 여러 마이크로서비스로 구성하기 때문에
  * 내부 서비스 간 또는 외부 서비스와 연결하고 상호작용하는 일이 많음&#x20;
* 서비스 간 연결성을 확보하고 API와 서비스 인터페이스를 잘 정의하는 것이 아주 중요&#x20;

#### 서비스 주도 상호작용&#x20;

* 마이크로서비스, 애플리케이션은 자신의 기능을 서비스로 외부에 제공&#x20;
* 마이크로서비스가 사용하는 외부 기능이나 자원들 역시 서비스 형태로 선언할 수 있음&#x20;
  * 이러한 유형의 서비스 => 지원 서비스라고 함&#x20;
* 서비스라는 개념&#x20;
  * 추상화를 통해 마이크로서비스 간 상호작용을 더 쉽고 편하게 만들어 줌&#x20;



* 필요한 서비스를 동적으로 찾을 수도 있음
  * dynamic service discovery
* 서비스 메타 정보를 스토어나 레지스트리에 보관할 수도 있음&#x20;
* 부하 분산과 같은 기능도 구현 가능&#x20;
* 쿠버네티스와 같은 컨테이너 오케스트레이션 플랫폼이 서비스를 최상위로 추상화하는 것도 바로 이러한 편리함!



*   클라우드 네이티브 애플리케이션을 마이크로서비스로 구성할 때&#x20;

    * 이러한 플랫폼에선 각 서비스의 기능들을 플랫폼이 제공하는 서비스 추상화로 선언할 수 있음&#x20;
    * ex) 쿠버네티스의 서비스 오브젝트&#x20;
    * eX) 데이터베이스나 메시지 큐와 같이 애플리케이션에서 사용하는 외부 애플리케이션들 역시&#x20;
    * 서비스로 선언하고 네트워크를 통해 접근해서 사용할 수 있음&#x20;



#### 서비스 간 통신 및 조합&#x20;

* 내부 서비스 간, 또는 애플리케이션과 외부 서비스 간 상호작용
  * 클라우드 네이티브 애플리케이션의 필수 요소&#x20;
* 네트워크를 통해 다양한 통신 패턴과 프로토콜을 사용해서 이루어짐&#x20;
* 여러 서비스를 연결하여 새로운 조합을 만들거나 이벤트 주도 생산자 및 소비자를 만들 수 있음&#x20;
* 애플리케이션 수준의 보안, 회로 차단기(circuit breaker) 또는 타임아웃과 백오프를 가지는 재시도 기능과 같은 탄력적인 통신, 라우팅, 매트릭 수집 및 보고, 관측 가능성 수집 도구에&#x20;
  * 정보 전송과 같은 비즈니스 기능에 포함되지 않는 특정 기능들 역시 이런 서비스 간 상호작용의 일환으로 구현됨&#x20;
* 서비스 개발자로서 서비스 개발에 필요한 이러한 기술 스택은 반드시 갖춰야 함&#x20;
* 탄력적인 통신과 같이 서비스의 비즈니스 로직과 직접적인 연관성은 없지만 유용한 기능들은&#x20;
  * 애플리케이션 자체에서 구현하기보다는 주로 애플리케이션이 실행되는 클라우드 서비스 환경에서 제공하는 기능들로 구현됨&#x20;

#### 관리형 API로 기능들을 외부에 제공하기&#x20;

* 특정 기능의 경우, 서비스 개념을 더 확장해서 managed API로 제공해야 할 수도 있음&#x20;
* 클라우드 네이티브 애플리케이션은 기능 대부분을 내부 or 외부에 관리형 서비스나 API 형태로 제공&#x20;
* API 게이트웨이와 API 관리와 컨트롤 플레인을 통해
  * 보안, 스로틀링, 캐싱, 버전 관리, 제공하는 API로 수익을 창출하기 위한 과금 계산&#x20;
  * 개발자용 포털 생성 등과 같은 기능을 구현함&#x20;

#### API 게이트웨이

* 제공하는 기능들에 접근할 수 있는 진입로 역할을 담당하고, 개발자 포털은 API를 둘러싼 생태계 조성에 꼭 필요한 기능&#x20;
* API 관리는 외부 & 내부 서비스에도 적용됨&#x20;
* API 관리 기능은 쿠버네티스와 같은 컨테이너 오케스트레이션 플랫폼에 내장된 기능이 아니기 때문&#x20;
  * 별도의 API 관리 기술을 통해 마이크로서비스를 관리형 API로 제공해야 함&#x20;

























