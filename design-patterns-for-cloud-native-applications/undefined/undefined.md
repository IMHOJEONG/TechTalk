# 동기 메시징 패턴



* 마이크로서비스 : 하나 이상의 다른 마이크로서비스가 제공하는 기능들을 호출하고 지정된 시간 내에 응답을 받는 식으로 비즈니스 기능을 구현할 수 있음&#x20;
  * 동기 메시징 패턴을 적용할 수 있음&#x20;
* 이 패턴에선, 마이크로서비스가 자신이 사용하는 다른 마이크로서비스와 의존 관계를 가지게 됨&#x20;
*   ex) 온라인 쇼핑몰 애플리케이션을 만든다고 가정&#x20;

    * 검색 서비스를 제공하는 마이크로서비스는 사용자가 입력한 질의를 전달받아&#x20;
    * 관련 마이크로서비스나 시스템이 제공하는 기능들을 호출해 내용을 찾고 다음 사용자에게 그 결과를 전달해야 할 것&#x20;



### 요청-응답 패턴&#x20;

* 클라우드 네이티브 애플리케이션에서 사용하는 통신 패턴 중 가장 많이 사용하는 패턴&#x20;
* 분산 컴퓨팅 전반에 걸쳐 애용하는 방식&#x20;
* 요청-응답 패턴에선 통신에 참여하는 각 주체가 적절한 시간 내에 데이터를 서로 주고받아야 함&#x20;



* 요청-응답 패턴에서 한 마이크로서비스가 하나 이상의 다른 마이크로서비스나 시스템에 요청을 보내고 그 응답을 기다림&#x20;
* 클라이언트 애플리케이션의 비즈니스 로직은 응답이 올 때까지 동작을 멈추고 대기하며&#x20;
  * 통신 채널은 클라이언트 애플리케이션이 응답을 받을 때까지 연결을 유지해야 함&#x20;



* 요청-응답 패턴에서 클라이언트와 서버 애플리케이션은 우선 연결을 맺은 다음 동기 방식으로 데이터를 주고 받음&#x20;
  * 메시지 : 주고받는 데이터&#x20;
* 서비스 간 연결이 맺어지면 클라이언트는 데이터에 대한 요청을 서버 측에 전달하고 응답이 올 때까지,
  * 또는 타임아웃이라고 불리는 지정된 최대 시간까지 기다림&#x20;
* 질의를 주고 결과를 받는 방식과 비슷하여 때때로는 질의 기반 상호작용이라고 불림&#x20;



* 요청-응답 패턴&#x20;
  * 클라우드 네이티브 애플리케이션 내의 여러 비즈니스 기능 중 특히&#x20;
    * 즉각 데이터를 요청하고 바로 응답을 받아야 하는 곳에서 주로 사용&#x20;
  * 외부에 서비스 기능을 제공하는 경우 대부분 이 패턴으로 구현&#x20;
  * 기저 네트워크나 프로토콜에 영향을 받지 않기 때문에 주고받는 메시지 형식에 따라서 다양한 기술을 적용해 구현할 수 있다는 장점&#x20;



* 특히, HTTP, RESTful 서비스를 사용하는 대부분의 마이크로서비스를 이 패턴으로 구현&#x20;
  * 초창기 클라우드 네이티브 애플리케이션에서 가장 널리 사용된 방식&#x20;



* 하지만, 최근 사용하는 요청-응답 패턴은 초창기 패턴과는 그 사용 방법이나 요구사항이 많이 다름&#x20;



* 동기화된 요청-응답 패턴이 클라우드 네이티브 애플리케이션에서 가장 자주 사용하는 패턴&#x20;
  * 이 패턴을 많이 사용할수록 마이크로서비스 간의 의존성이 생긴다는 단점&#x20;
* 다른 서비스에 요청을 보내고 응답을 보낸다는 것&#x20;
  * 해당 서비스가 다른 서비스에 묵시적인 의존성을 가진다는 뜻&#x20;
  * 서비스 수가 많지 않으면 큰 문제가 되지 않겠지만, 요청-응답 패턴으로 연결되는 서비스가 많아질수록 의존성 연결 고리는 기하급수적으로 늘어나고 복잡\

* 연결이 복잡해지면 성능에 병목 현상이 있거나 오류가 발생하는 서비스들이 다른 서비스들에 영향을 미칠 가능성이 있음&#x20;



* 요청-응답 패턴은 반드시 외부 사용자, 시스템, 마이크로서비스 간 서로 메시지를 계속 주고받는 방식으로 통신할 때만 사용하는 것이 좋음&#x20;
  * 그 외의 경우 => 비동기 통신 방법이 좋음&#x20;
* 애플리케이션 개발에선 요청-응답 패턴과 다른 통신 패턴을 같이 사용하는 경우가 많음&#x20;



* 관련 패턴&#x20;
  * 요청-응답 패턴은 다음 패턴들과 함께 사용하는 경우가 많음&#x20;
    * **서비스 오케스트레이션 및 API 게이트웨이 패턴**
      * 서비스들을 조합하고 관리형 API로 외부에 기능들을 제공할 때 요청-응답 방식을 많이 사용&#x20;
    * **요청-회신 패턴**&#x20;
      * 요청-회신 패턴은 중간 매체를 통해 메시지 큐를 사용하는 것과 비슷한 효과를 냄&#x20;



#### 원격 프로시저 호출 패턴&#x20;

* RPC - 분산된 원격 애플리케이션의 프로시저를 마치 자기 자신의 프로시저처럼 호출하고 사용할 수 있게 하는 동기화 통신 패턴&#x20;
* 특정 마이크로서비스가 자신의 비즈니스 로직을 함수처럼 만들고 다른 서비스가 이 함수를 호출함으로써 비즈니스 기능을 이용할 수 있음&#x20;
* ex) 어떻게 동작하는지 이해하기 위해 온라인 쇼핑몰 Application에서 상품 세부 정보를 알려주는 마이크로서비스&#x20;
  * 서비스 기능을 원격 프로시저 호출 형태로 만들어서 외부의 클라이언트나 기타 애플리케이션이 마치 자신의 함수를 호출하는 것처럼 코드를 작성하고 사용할 수 있음&#x20;
  * 기반이 되는 RPC 프레임워크가 네트워크를 통해 원격 메서드를 호출하는 복잡한 부분을 모두 알아서 처리하기 때문&#x20;
    * 애플리케이션 개발자는 네트워크에서 어떤 식으로 통신이 이루어지는지 알 필요가 전혀 없음&#x20;
* RPC 패턴을 사용하면 서로 다른 프로그래밍 언어와 기술을 사용해서 클라이언트와 서버 애플리케이션을 만들 수도 있음&#x20;



* 서비스 개발자가 RPC 패턴을 적용할 때는 가장 먼저 사용자에게 제공할 원격 메서드에 대한 세부 정보, 서비스 이름, 이름 분석, 서비스 간 정보를 교환하기 위해 사용하는 데이터 타입 등을 명세&#x20;
  * 서비스 정의부터 해야함&#x20;
  * 서비스에 대한 정의 : 주로 인터페이스 정의 언어(IDL)를 사용해서 명세&#x20;



* RPC 패턴을 사용하면 => 서비스 정의를 통해 RPC 통신에 필요한 저수준 프로토콜을 처리해주는 클라이언트 측 코드, 서버 측 코드를 자동으로 만들 수 있음&#x20;
  * 이렇게 생성되는 코드 컴포넌트 => 서버 or 클라이언트 스터브라고 함&#x20;



*   RPC 사용자 or 마이크로서비스 비즈니스 로직 개발자는 사용하는 RPC 기술에 대한 세부 내용을 알 필요가 없음&#x20;

    * 단지 스터브가 제공하는 추상화 계층을 사용해서 애플리케이션의 비즈니스 로직을 구현하는 데만 집중하면 됨&#x20;


*















































