---
description: '- Javascript의 코드 개선'
---

# Index

* 설계가 나쁜 시스템은 수정하기 어렵다&#x20;
* 원하는 동작을 수행하도록 하기 위해 수정해야 할 부분을 찾고, 기존 코드와 잘 맞물려 작동하게 할 방법을 강구하기가 어렵기 때문&#x20;
* 무엇을 수정할지 찾기 어렵다면 실수를 저질러서 버그가 생길 가능성도 높아짐&#x20;



*   글쓴이

    * 수백 줄짜리 코드를 수정할 때면 먼저 프로그램의 작동 방식을 더 쉽게 파악할 수 있도록 코드를 여러 함수와 프로그램 요소로 재구성


* 프로그램의 구조가 빈약하다면 대체로 구조부터 바로잡은 뒤에 기능을 수정하는 편이 작업하기가 훨씬 수월

> 프로그램이 새로운 기능을 추가하기에 편한 구조가 아니라면, 먼저 기능을 추가하기 쉬운 형태로 리팩터링하고 나서 원하는 기능을 추가한다.&#x20;



ex) 사용자의 입맛에 맞게 수정?

1. 청구  내역을  HTML로 출력하는 기능?

* 이러한 변경이 어느 부분에 영향을 주는가?
* 청구 결과에 문자열을 추가하는 문장 각각을 조건문으로 감싸야 함&#x20;
* statement() 함수의 복잡도가 크게 증가한다&#x20;
* 해결책 1 : 이 함수의 복사본을 만들고 복사본에서 HTML을 출력하는 식&#x20;
  * 복사하는 일 자체는 부담 X, 나중에 수많은 문제를 일으킬 여지가 존재&#x20;
  * 청구서 작성 로직 변경 시마다, 기존 함수와 HTML 버전 함수 모두를 수정, 항시 일관되게 수정했는지 확인해야 함&#x20;
* 로직을 변경할 일이 절대 없다면 이렇게 복사해서 붙이는 방식도 ㄱㅊ
  * 내 생각! => 과연????
* 오래 사용할 프로그램이라면 중복 코드는 골칫거리가 됨&#x20;



* 만약 변경이 공연료, 계산법에 영향을 준다면?
  * 새로운 요구사항은 한 부대씩 몰려오기 마련&#x20;



* 연극 장르, 공연료 정책이 달라질 때마다 statement 함수를 수정해야 한다?
  * statement를 복사해서 별도의 htmlStatement()를 만든다면
  * 모든 수정이 두 함수에 일관되게 반영되도록 보장해야함
  * 게다가 정책이 복잡해질수록 수정할 부분을 찾기 어려워지고 수정과정에서 실수할 가능성도 커진다



* 리팩토링이 필요한 이유!
  * 잘 작동하고 나중에 변경할 일이 절대 없다면 코드를 현재 상태로 놔둬도 아무런 문제가 없다&#x20;
  * 더 다듬어두면 물론 좋겠지만, 누군가 코드를 읽지 않는 한 아무런 피해가 없음&#x20;
  * 하지만, 그러다 다른 사람이 읽고 이해해야 할 일이 생겼는데 로직을 파악하기 어렵다면?????

#### 리팩토링의 첫 단계

* 항상 같음, 리팩터링할 코드 영역을 꼼꼼하게 검사해줄 테스트 코드를 만들어야 함&#x20;
* 테스트의 역할은 굉장히 중요&#x20;
* statement 함수의 테스트는?
  * 문자열을 반환, 다양한 장르의 공연들로 구성된 공연료 청구서 몇 개를 미리 작성해 문자열 형태로 준비해둔다면?

> 리팩터링하기 전에 제대로 된 테스트부터 마련한다. 테스트는 반드시 자가진단하도록 만든다.



* 리팩터링 시 테스트에 상당히 의지한다.
  * 내가 저지른 실수로부터 보호해주는 버그 검출기 역할을 해주기 때문&#x20;
  * 원하는 내용을 소스 코드와 테스트 코드 양쪽에 적어두면?
    * 두 번 다 똑같이 실수하지 않는 한 버그 검출기에 반드시 걸림
    * 이와 같은 중복 검사로 실수 가능성을 크게 줄일 수 있음&#x20;
* 테스트를 작성하는 데 시간이 좀 걸리지만, 신경 써서 만들어두면 디버깅 시간이 줄어서 전체 작업 시간은 오히려 단축됨&#x20;

#### statement() 함수 쪼개기&#x20;

* 긴 함수 리팩토링 => 전체 동작을 각각의 부분으로 나눌 수 있는 지점을 찾자&#x20;
*   코드를 분석해서 얻은 정보는 재빨리 코드에 반영해야 함&#x20;

    * 다시 분석하지 않아도, 코드 스스로가 자신이 하는 일이 무엇인지 얘기해줄 것&#x20;


* 코드 조각을 별도 함수로 추출하는 방식으로?
  * 추출한 함수에는 그 코드가 하는 일을 설명하는 이름을 지어준다
  * 나라면? calculateForOnePlay가 낫지 않을까 생각이 들지만?
* **함수 추출하기**
  * 별도 함수로 빼냈을 때 유효범위를 벗어나는 변수, 즉 새 함수에서는 곧바로 사용할 수 없는 변수가 있는지 확인한다.&#x20;
  * 함수 안에서 값이 바뀌는 변수는 조심해서 다루어야 함&#x20;



* 수정하고 나면 곧바로 컴파일하고 테스트해서 실수한 게 없는지 확인한다.
* 아무리 간단한 수정이라도 리팩터링 후에는 항상 테스트하는 습관을 들이는 것이 바람직하다&#x20;
* 사람은 실수하기 마련
  * 한 가지를 수정할 때마다 테스트하면, 오류가 생기더라도 변경 폭이 작기 때문에, 살펴볼 범위도 좁아서 문제를 찾고 해결하기가 훨씬 쉽다&#x20;



* 조금씩 변경하고 매번 테스트하는 것은 리팩터링 절차의 핵심&#x20;
  * 한 번에 너무 많이 수정하려다 실수를 저지르면 디버깅하기 어려워서 결과적으로 작업 시간이 늘어남&#x20;
* 조금씩 수정하여 피드백 주기를 짧게 가져가는 습관이 이러한 재앙을 피하는 길&#x20;



> 리팩터링은 프로그램 수정을 작은 단계로 나눠 진행한다. 그래서 중간에 실수하더라도 버그를 쉽게 찾을 수 있다.&#x20;

* 중첩함수로 만들면 바깥 함수에서 쓰던 변수를 새로 추출한 함수에 매개변수로 전달할 필요가 없어서 편함&#x20;
  * 지금 경우에는 달라질 게 없지만, 일반적으로 중첩 함수로 만들면 할 일 하나가 줄어드는 셈&#x20;
* 방금 수정한 사항을 테스트해보니 문제가 없음&#x20;
  * 하나의 리팩터링을 문제없이 끝낼 때마다 커밋함&#x20;
  * 그래야 중간에 문제가 생기더라도 이전의 정상 상태로 쉽게 돌아갈 수 있음&#x20;
  * 자잘한 변경들이 어느 정도 의미 있는 단위로 뭉쳐지면 공유 저장소로 Push 함



* 함수를 추출하고 나면 추출된 함수 코드를 자세히 들여다보면서 지금보다 명확하게 표현할 수 있는 간단한 방법은 없는지 검토
  * 변수의 이름을 더 명확하게 바꾸어보자&#x20;



* 자바스크립트와 같은 동적 타입 언어를 사용할 때는 타입이 드러나게 작성하면 도움됨&#x20;
  * 매개변수의 역할이 뚜렷하지 않을 때 부정관사를 붙이는 습관이 있으시대

> 컴퓨터가 이해하는 코드는 바보도 작성할 수 있다. 사람이 이해하도록 작성하는 프로그래머가 진정한 실력자다&#x20;

* 좋은 코드라면 하는 일이 명확히 드러나야 하며, 이 때 변수 이름은 커다란 역할을 한다.&#x20;
* 명확성을 높이기 위한 이름 바꾸기에는 조금도 망설이지 말기 바란다.&#x20;



#### play 변수 제거하기&#x20;

* aPerformance : Loop 변수에서 오기 때문에 반복문을 한 번 돌때마다 자연스레 값이 변경됨&#x20;
* 긴 함수를 잘게 쪼갤 때마다 play 같은 변수를 최대한 제거
* 임시 변수들 때문에 로컬 범위에 존재하는 이름이 늘어나서 추출 작업이 복잡해지기 때문&#x20;
  * 이를 해결해주는 리팩터링으로는 **임시 변수를 질의 함수로 바꾸기**&#x20;



* 컴파일-테스트-커밋한 다음 변수 인라인하기를 적용
*   다시 컴파일-테스트-커밋함

    * **함수 선언 바꾸기**&#x20;

    ****
* 컴파일-테스트-커밋
  * 이전 코드는 루프를 한 번 돌 때마다 공연을 조회했음&#x20;
  * 리팩터링한 코드에서는 세 번이나 조회
* 리팩터링과 성능의 관계 => 지금에서는 이렇게 변경해도 성능에 큰 영향은 없음&#x20;



* 심각하게 느려지더라도 제대로 리팩터링된 코드베이스는 그렇지 않은 코드보다 성능을 개선하기가 훨씬 수월함&#x20;



* 지역 변수를 제거해서 얻는 가장 큰 장점&#x20;
  * 추출 작업이 훨씬 쉬워진다는 것&#x20;
  * 유효범위를 신경 써야 할 대상이 줄어들기 때문&#x20;
* 임시 변수는 나중에 문제를 일으킬 수 있음&#x20;
  * 자신이 속한 루틴에서만 의미가 있어서 루틴이 길고 복잡해지기 쉬움&#x20;



* 이름짓기는 중요하면서도 쉽지 않은 작업
  * 긴 함수를 작게 쪼개는 리팩터링은 이름을 잘 지어야만 효과가 있음&#x20;
  * 이름이 좋으면 함수 본문을 읽지 않고도 무슨 일을 하는지 알 수 있음&#x20;
* 단번에 좋은 이름을 짓기는 쉽지 않음&#x20;
  * 처음에는 당장 떠오르는 최선의 이름을 사용하다가, 나중에 더 좋은 이름이 떠오를 때 바꾸는 식이 좋다&#x20;
* 흔히 코드를 두 번 이상 읽고 나서야 가장 적합한 이름이 떠오르곤 함&#x20;



* 반복문을 쪼개서 성능이 느려지지 않을까 걱정할 수 있다.&#x20;
  * 반복문이 중복되는 것을 꺼리는 이들이 많음&#x20;
  * 이 정도 중복은 성능에 미치는 영향이 미미할 때가 많음&#x20;
* 실제로 이번 리팩터링 전과 후의 실행시간을 측정해보면 차이를 거의 느끼지 못할 것&#x20;



* 경험 많은 프로그래머조차 코드의 실제 성능을 정확히 예측 못함&#x20;
  * 똑똑한 컴파일러들은 최신 캐싱 기법 등으로 무장하고 있어서 우리의 직관을 초월하는 결과를 내어주기 때문&#x20;



* SW 성능은 대체로 코드의 몇몇 작은 부분에 의해 결정되므로 그 외의 부분은 수정한다고 해도 성능 차이를 체감할 수 없음&#x20;



* 리팩터링이 성능에 상당한 영향을 주기도 함&#x20;
  * 그런 경우라도 나는 개의치 않고 리팩터링함&#x20;
  * 잘 다듬어진 코드라야 성능 개선 자겁도 훨씬 수월하기 때문&#x20;



* 리팩터링 과정에서 성능이 크게 떨어졌다면 리팩터링 후 시간을 내어 성능을 개선한다&#x20;
  * 이 과정에서 리팩터링된 코드를 예전으로 되돌리는 경우도 있지만,&#x20;
    * 대체로 리팩터링 덕분에 성능 개선을 더 효과적으로 수행할 수 있음&#x20;
* 결과적으로 더 깔끔하면서 더 빠른 코드를 얻게 됨&#x20;



* 리팩터링으로 인한 성능 문제에 대한 조언&#x20;
  * **특별한 경우가 아니라면 일단 무시하라**
  * 리팩터링 때문에 성능이 떨어진다면, 하던 리팩터링을 마무리하고 나서 성능을 개선하자&#x20;

#### 사용된 리팩토링&#x20;

* **반복문 쪼개기, 문장 슬라이드하기, 함수 추출하기, 변수 인라인하기**



* 항상 단계를 이처럼 잘게 나누는 것은 아니지만, 그래도 상황이 복잡해지면 단계를 더 작게 나누는 일을 먼저 함&#x20;



* 특히, 리팩터링 중간에 테스트가 실패하고 원인을 바로 찾지 못하면&#x20;
  * 가장 최근 커밋으로 돌아가서 테스트에 실패한 리팩터링의 단계



* 커밋을 자주 했기 때문이기도 하고, 코드가 복잡할수록 단계를 작게 나누면 작업 속도가 빨라지기 때문&#x20;



#### 계산 단계와 포맷팅 단계 분리하기&#x20;

* 프로그램의 논리적인 요소를 파악하기 쉽도록 코드의 구조를 보강하는 데 주안점을 두고 리팩터링 함&#x20;
* 리팩터링 초기 단계에서 흔히 수행하는 일&#x20;
* 복잡하게 얽힌 덩어리를 잘게 쪼개는 작업은 이름을 잘 짓는 일만큼 중요



* 골격은 충분히 개선됐으니 이제 원하던 기능 변경을 수행해야 함&#x20;



* 복사를 한 이유 => 함수로 건넨 데이터를 수정하기 싫어서&#x20;
  * 가변 데이터는 금방 상하기 때문에 나는 데이터를 최대한 불변처럼 취급한다.&#x20;
  *





